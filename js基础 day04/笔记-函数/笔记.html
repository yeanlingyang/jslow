<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>笔记</title>
  <!-- <link rel="stylesheet" href="lib/css/monokai-sublime.css"> -->
  <link rel="stylesheet" href="lib/css/default.min.css">
  <link rel="stylesheet" href="lib/css/vs2015.css">
  <link rel="stylesheet" href="lib/css/zTreeStyle/zTreeStyle.css">
  <link rel="stylesheet" href="lib/css/base.css">
  <link rel="stylesheet" href="lib/css/index.css">
</head>

<body>
  <div style='width:25%;'>
    <ul id="tree" class="ztree" style='width:100%'>

    </ul>
  </div>
  <div id='readme' style='width:70%;margin-left:20%;'>
    <article class='markdown-body'><h1 id="-">函数</h1>
<h2 id="-">函数基础知识</h2>
<h3 id="-">为什么要有函数</h3>
<blockquote>
<p>在写代码的时候，有一些常用的代码需要书写多次，如果直接复制粘贴的话，会造成大量的冗余代码。</p>
<p>函数可以封装一段重复的JavaScript代码，它只需要声明一次，就可以被多次调用。</p>
</blockquote>
<p>重复代码、冗余代码的缺点：</p>
<ol>
<li><p>代码重复，可阅读性差</p>
</li>
<li><p>不易维护，如果代码逻辑改变了，所有地方的代码都要跟着改变，效率太低。</p>
</li>
</ol>
<h3 id="-">函数的声明与调用</h3>
<p>声明函数的语法：</p>
<pre><code class="lang-javascript">function 函数名(){
    //函数体
}
</code></pre>
<p>调用函数的语法：</p>
<pre><code class="lang-javascript">函数名();
</code></pre>
<p>特点：</p>
<pre><code class="lang-javascript">1. 函数声明的时候，函数体并不会执行，函数体只有在调用的时候才会执行，
2. 可以调用多次
</code></pre>
<p>代码示例：</p>
<pre><code class="lang-javascript">//声明函数
function sayHi(){
  console.log(&quot;吃了没？&quot;);
}
//调用函数
sayHi();
</code></pre>
<p>思考：</p>
<pre><code class="lang-javascript">1. 封装一个打招呼的函数
2. 封装一个函数，计算两个数的和
3. 封装一个函数，计算1-100之间所有数的和
</code></pre>
<h3 id="-">函数的参数</h3>
<blockquote>
<ol>
<li>形参（形式参数）：在函数声明时，设置的参数。作用是占位置。</li>
<li>实参（实际参数）：在函数调用时，传入的参数。作用：函数调用时，会把实参的值赋值给形参，这样形参就有了值。</li>
</ol>
</blockquote>
<p>语法：</p>
<pre><code class="lang-javascript">//带参数的函数声明
function 函数名(形参1, 形参2, 形参...){
  //函数体
}

//带参数的函数调用
函数名(实参1, 实参2, 实参3);
</code></pre>
<p>思考：</p>
<pre><code class="lang-javascript">1. 计算1-n之间所有数的和
2. 计算两个数的和
3. 计算m-n之间所有数的积
</code></pre>
<p>注意：</p>
<ul>
<li>形参在声明时，值不固定，只有在调用的时候，形参的值才确定，形参的值会跟着函数调用时的实参不一样而不一样。</li>
<li>如何确定形参：在声明函数的时候，碰到不确定的值的时候，就可以定义成形参。</li>
</ul>
<h3 id="-">函数的返回值</h3>
<blockquote>
<p>当函数执行完的时候，我们期望函数给我一些反馈（比如计算的结果），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值</p>
</blockquote>
<p>返回值语法：</p>
<pre><code class="lang-javascript">//声明一个带返回值的函数
function 函数名(形参1, 形参2, 形参...){
  //函数体
  return 返回值;
}

//可以通过变量来接收这个返回值
var 变量 = 函数名(实参1, 实参2, 实参3);
</code></pre>
<p>思考：</p>
<pre><code class="lang-javascript">1. 计算1-n之间所有数的和,并且返回结果
2. 计算两个数的和，并且返回结果
3. 计算m-n之间所有数的积，并且返回结果
</code></pre>
<p>注意：</p>
<ul>
<li>函数的调用结果就是返回值，因此我们可以直接对函数调用结果进行操作。</li>
</ul>
<h3 id="-">函数三要素</h3>
<p>函数三要素包括：函数名、参数、返回值</p>
<pre><code class="lang-javascript">function getArea (r) {
    return Math.PI * r * r;
}
</code></pre>
<p>思考1：</p>
<pre><code class="lang-javascript">1. 求任意半径的圆的面积
2. 求任意半径的圆的周长
3. 求任意2个数中的最大值
</code></pre>
<p>思考2：</p>
<pre><code class="lang-javascript">1. 求任意数组中的最大值
2. 求任意数组中的最小值
3. 翻转任意数组，返回一个新的数组
4. 对任意数组从小到大排序
</code></pre>
<h2 id="-">函数高级知识</h2>
<h3 id="-">函数调试</h3>
<p>断点调试：</p>
<pre><code class="lang-javascript">1.    F8：跳到下一个断点，如果后面没有断点了，那么代码直接执行完。
2.    F10：单步调试（跳过函数调用）
3.    F11：单步调试（进入函数调用）
4.    shift+F11：跳出函数调用
</code></pre>
<h3 id="-">函数内部可以调用函数</h3>
<blockquote>
<p>在函数内部是可以继续调用别的函数的。</p>
</blockquote>
<pre><code class="lang-javascript">function fn1() {
    console.log(&quot;fn1开始...&quot;);
    fn2();
    console.log(&quot;fn1结束...&quot;);
}

function fn2 () {
    console.log(&quot;执行fn2的代码&quot;); 
    console.log(&quot;执行fn2的代码&quot;);
    console.log(&quot;执行fn2的代码&quot;);
}
//在函数1中调用了函数2
fn1();
</code></pre>
<h3 id="-">全局变量与局部变量</h3>
<p>全局变量：在最函数外，script标签内声明的变量就是全局变量，全局变量在任何地方都能访问的到。</p>
<p>局部变量：在函数中声明的变量，就是局部变量，局部变量只有在当前函数体内能够访问。</p>
<p>隐式全局变量：没有使用var定义的变量也是全局变量。</p>
<pre><code class="lang-javascript">var num = 11;//全局变量
function fn() {
  var num1 = 22;//局部变量
  num2 = 33;//隐式全局变量
  console.log(num1);
}
fn();
</code></pre>
<p>变量的查找规则：</p>
<ul>
<li>自己有就用自己的，自己没有就用外面的。</li>
</ul>
<pre><code class="lang-javascript">var num = 11;
function fn() {
  var num = 22;
  console.log(num);//22
}
fn();
console.log(num);//11
</code></pre>
<h3 id="-">预解析</h3>
<p>js执行代码分为两个过程：</p>
<ul>
<li>预解析过程（变量与函数提升）</li>
<li>代码一行一行执行</li>
</ul>
<p>预解析过程：</p>
<ol>
<li>函数优先，先提升function，后提升var</li>
<li>遇到重名的var会被忽略。</li>
<li>遇到重名的function会被覆盖。</li>
</ol>
<p>思考：</p>
<pre><code class="lang-javascript">//1. getCool
//2
console.log(a);
function a() {
  console.log(&quot;aaaaa&quot;);
}
var a = 1;
console.log(a);
</code></pre>
<p>面试题：</p>
<pre><code class="lang-javascript">//1. 
var num = 10;
fn1();
function fn1() {
  console.log(num);
  var num = 20;
}

//2. 
var a = 18;
fn2();
function fn2() {
    var b = 9;
    console.log(a);
    console.log(b);
}

//3.
fn3();
console.log(c);
console.log(b);
console.log(a);
function fn3() {
  a = b = c = 9;
  console.log(a);
  console.log(b);
  console.log(c);
}
</code></pre>
<h3 id="-">声明函数的两种方式</h3>
<p>函数声明(命名函数)：</p>
<pre><code class="lang-javascript">function 函数名(){
  //函数体
}
</code></pre>
<p>函数表达式(匿名函数)：</p>
<pre><code class="lang-javascript">var 函数名 = function(){
  //函数体
}
</code></pre>
<p>这两种函数声明的区别：</p>
<ol>
<li>命名函数可以先调用，在声明，因为预解析</li>
<li>函数表达式必须先声明，再调用（在DOM中注册事件的时候用的非常的多）</li>
</ol>
<h3 id="-">匿名函数</h3>
<blockquote>
<p>匿名函数：没有名字的函数</p>
</blockquote>
<p>匿名函数如何使用：</p>
<pre><code>1. 将匿名函数赋值给一个变量，这样就可以通过变量进行调用
2. 匿名函数自调用
</code></pre><p>关于自执行函数（匿名函数自调用）的作用：防止全局变量污染。</p>
</article>
  </div>
</body>
</html>
<script type="text/javascript" src="lib/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="lib/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="lib/js/ztree_toc.min.js"></script>
<script type="text/javascript" src="lib/js/toc_conf.js"></script>
<script src="lib/js/highlight.min.js"></script>
<script>
  $(document).ready(function () {
    // 代码高亮的js代码
    hljs.initHighlightingOnLoad();

    //生成侧边栏的代码
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)

    var conf = eval(jquery_ztree_toc_opts);
    $('#tree').ztree_toc(conf);
  });
</script>