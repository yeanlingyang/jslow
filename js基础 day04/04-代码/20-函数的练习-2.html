<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>

  <script>

    // 1. 求任意数组中的最大值
    // function getMax(arr) {
    //   // 先假定一个最大值
    //   var max = arr[0];

    //   // 遍历数组, 让后面的项和最大值比, 如果发现大了, 更新最大值
    //   for (var i = 1; i < arr.length; i++) {
    //     if (arr[i] > max) {
    //       max = arr[i];
    //     }
    //   } 

    //   return max;
    // }
    // var myArr = [1, 3, 111, 120, 88];
    // var arrMax = getMax(myArr);
    // console.log(arrMax);


    // 2. 求任意数组中的最小值
    // function getMin(arr) {
    //   // 先假定一个最小值
    //   var min = arr[0];

    //   for (var i = 1; i < arr.length; i++) {
    //     if (arr[i] < min) {
    //       // 更新最小值
    //       min = arr[i];
    //     }
    //   }

    //   return min;
    // }
    // var myArr = [1, 3, 111, 120, 88];
    // var arrMin = getMin(myArr);
    // console.log(arrMin);



    // 3. 翻转任意数组，返回一个新的数组
    // function reverseArr(arr) {
    //   var newArr = []; 
    //   // 倒序遍历传进来的数组, 依次给 newArr 添加项
    //   for (var i = arr.length-1; i >= 0; i--) {
    //     newArr.push(arr[i])
    //   }
    //   return newArr;
    // }

    // var myArr = ['aa', 'bb', 'cc', 'dd'];
    // var result = reverseArr(myArr);
    // console.log(result);


    // 4. 对任意数组从小到大排序   (复习冒泡排序)

    // 初级版
      // 1. 先排出一个最大值
      //    (1) 先遍历数组
      //    (2) 让 arr[i] 和 arr[i+1] 比
      //    (3) 如果 arr[i] > arr[i+1] 交换位置
      // 2. 重复排几次即可, 双重for循环, 比出所有的最大值   

    // 优化:
    //   中级优化: 每排一趟, 都可以排出一个最大值, 每趟都可以少比一次
    //   高级优化: 假设成立法, 如果已经排好序了, 后面不需要排了

    function sortArr(arr) {
      // 外层控制趟数, 7个数比6趟即可
      for (var j = 0; j < arr.length - 1; j++) {

        // 在每趟比较之前, 假设已经排好了
        var flag = true;

        for (var i = 0; i < arr.length - 1 - j; i++) {
          if (arr[i] > arr[i + 1]) {
            // 交换位置
            var temp = arr[i];
            arr[i] = arr[i + 1];
            arr[i + 1] = temp;
            flag = false;
          }
        }

        // 如果一趟下来, 没有任何的交换, 说明排好了, flag true
        if (flag) {
          break;  // 排好了, 后面的就不需要执行了
        }
      }

      return arr;
    }

    // 测试1:
    var myArr1 = [1, 7, 88, 126, 35];
    var result1 = sortArr(myArr1);
    console.log(result1);

    // 测试2:
    var myArr2 = [3, 100, -1, 36, 18];
    var result2 = sortArr(myArr2);
    console.log(result2);

  </script>
</body>

</html>